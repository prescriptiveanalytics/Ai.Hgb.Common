namespace Ai.Hgb.Common.Entities {
  public class RoutingTable : ICloneable {
    
    public List<Route> Routes { get; set; }
    public List<Point> Points { get; set; }

    //public List<Route> Routes {
    //  get { return routes; }
    //  private set { routes = value; }
    //}
    //public List<Point> Points {
    //  get { return points; }
    //  private set { points = value; }
    //}

    public RoutingTable() {
      Routes = new List<Route>();
      Points = new List<Point>();
    }

    public object Clone() {
      var t = new RoutingTable();
      t.Points.AddRange(Points.Select(x => (Point)x.Clone()));
      t.Routes.AddRange(Routes.Select(x => (Route)x.Clone()));

      return t;
    }

    public RoutingTable ExtractForPoint(string id) {
      var t = new RoutingTable();

      t.Routes.AddRange(Routes.Where(x => x.Source.Id == id || x.Sink.Id == id));
      Points.AddRange(t.Routes.Select(x => x.Source));
      Points.AddRange(t.Routes.Select(x => x.Sink));

      return t;
    }

    public void AddPoint(Point n) {
      Points.Add(n);
    }

    public void AddRoute(Route e) {
      Routes.Add(e);
    }

    public void RemovePoint(string id) {
      Routes.RemoveAll(x => x.Source.Id == id || x.Sink.Id == id);
      Points.RemoveAll(x => x.Id == id);
    }

    public void RemoveRoute(string id) {
      Routes.RemoveAll(x => x.Source.Id == id || x.Sink.Id == id);
    }
  }

  public class Route : ICloneable, IEquatable<Route> {

    public string Id { get; set; }
    public Point Source { get; set; }
    public Port SourcePort { get; set; }
    public Point Sink { get; set; }
    public Port SinkPort { get; set; }
    public string Query { get; set; }

    public Route() { }
    public Route(string id, Point source, Point sink, string query = null) {
      Id = id;
      Source = source;
      Sink = sink;
      Query = query;
    }
    public Route(string id, Point source, Port sourcePort, Point sink, Port sinkPort, string query = null) {
      Id = id;
      Source = source;
      SourcePort = sourcePort;
      Sink = sink;
      SinkPort = sinkPort;
      Query = query;
    }

    public object Clone() {
      return new Route(Id, Source, SourcePort, Sink, SinkPort, Query);
    }

    public string GetRoutingString(string delimiter) {
      return $"{Source.Typename}{delimiter}{Source.Id}";
    }

    public bool Equals(Route? other) {
      return Source == other.Source && SourcePort == other.SourcePort && Sink == other.Sink && SinkPort == other.SinkPort;
    }

    public static bool operator ==(Route left, Route right) {
      return left.Equals(right);
    }

    public static bool operator !=(Route left, Route right) {
      return !left.Equals(right);
    }
  }

  public class Point : ICloneable, IEquatable<Point> { // Location, Station, 
    public string Id { get; set; }

    public string Typename { get; set; }

    public string FullyQualifiedTypename { get; set; }

    public List<Port> Ports { get; set; }

    public Point() { }

    public Point(string id, string typename, string fullyQualifiedTypename, List<Port> ports) {
      Id = id;
      Typename = typename;
      FullyQualifiedTypename = fullyQualifiedTypename;
      Ports = ports;
    }

    public object Clone() {
      return new Point(Id, Typename, FullyQualifiedTypename, Ports);
    }

    public string GetRoutingString(string delimiter) {
      return $"{Typename}{delimiter}{Id}";
    }

    public bool Equals(Point? other) {
      return Id == other.Id && Typename == other.Typename && FullyQualifiedTypename == other.FullyQualifiedTypename;
    }

    public static bool operator ==(Point left, Point right) {
      return left.Equals(right);
    }

    public static bool operator !=(Point left, Point right) {
      return !left.Equals(right);
    }
  }

  public class Port :ICloneable, IEquatable<Port> {
    public string Id { get; set; }
    public PortType Type { get; set; }

    public List<string> OutPayloadTypes { get; set; }
    public List<string> InPayloadTypes { get; set; }
    public List<Tuple<string, string>> OutPayloadNamedTypes { get; set; }
    public List<Tuple<string,string>> InPayloadNamedTypes { get; set; }

    // will be generated by orchestrator
    // e.g. for a producer-consumer application with MQTT protocol: runId_XXX/pro/docs/
    // --> runId_XXX = generated, unique id
    // --> pro = name of the producer node
    // --> docs = name of producer node's port
    public string Address { get; set; }

    public Port() { }

    public object Clone() {
      return new Port() { Id = Id, Type = Type,
        OutPayloadTypes = OutPayloadTypes.ToList(),
        InPayloadTypes = InPayloadTypes.ToList(),
        OutPayloadNamedTypes = OutPayloadNamedTypes.ToList(),
        InPayloadNamedTypes = InPayloadNamedTypes.ToList()
      };
    }

    public bool Equals(Port? other) {
      return Id == other.Id && Type == other.Type;
    }

    public static bool operator ==(Port left, Port right) {
      return left.Equals(right);
    }

    public static bool operator !=(Port left, Port right) {
      return !left.Equals(right);
    }
  }

  public enum PortType {
    In,
    Out,
    Producer,
    Consumer,
    Client,
    Server
  }
}
